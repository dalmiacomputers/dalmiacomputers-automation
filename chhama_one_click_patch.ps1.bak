<#
chhama_one_click_patch.ps1
One-click patch for dalmiacomputers.in via PowerShell.

Features:
 - Downloads remote FTP/FTPS site to ./backup_<TS>/
 - Generates emergency patch files (css, robots, sitemap, pages, assets)
 - Uploads generated patch files to remote site
 - Verifies HTTP(S) response of the site
 - Logs output to chhama_patch_<TS>.log

Requirements / Notes:
 - Recommended: WinSCP installed or winscpnet.dll present in same folder (for FTPS/SFTP support).
   Official: https://winscp.net/eng/docs/library
 - Fallback: basic FTP (non-TLS) using .NET FtpWebRequest if WinSCP not available.
 - PowerShell 5+ recommended (works in PowerShell Core too).
 - Keep your FTP credentials ready.
 - Script saves a full backup before making changes (important).
#>

#region Helpers / setup
$TS = (Get-Date).ToString("yyyyMMddTHHmmssZ")
$LogFile = "chhama_patch_$TS.log"
function Log {
    param([string]$Text)
    $line = "[{0}] {1}" -f (Get-Date -Format o), $Text
    Write-Host $line
    Add-Content -Path $LogFile -Value $line
}
Set-StrictMode -Version Latest
#endregion

#region Prompt / Input
Write-Host "=== CHHAMA One-Click Patch (PowerShell) ===" -ForegroundColor Cyan
$ftpHost = Read-Host "FTP/FTPS host (e.g. ftp.dalmiacomputers.in)"
if ([string]::IsNullOrWhiteSpace($ftpHost)) { Write-Error "Host required"; exit 1 }
$ftpUser = Read-Host "FTP username"
if ([string]::IsNullOrWhiteSpace($ftpUser)) { Write-Error "User required"; exit 1 }
$ftpPassSecure = Read-Host "FTP password (input will be hidden)" -AsSecureString
$ftpPass = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($ftpPassSecure))
$remoteRoot = Read-Host "Remote site path (default /public_html). Enter / for root" 
if ([string]::IsNullOrWhiteSpace($remoteRoot)) { $remoteRoot = "/public_html" }
$domain = Read-Host "Public domain for verification (e.g. dalmiacomputers.in)"
if ([string]::IsNullOrWhiteSpace($domain)) { $domain = $ftpHost }
$useSftpInput = Read-Host "Use SFTP/FTPS (recommended)? (Y/n)"
$useSecure = $true
if ($useSftpInput -match '^(n|N)') { $useSecure = $false }

# Local paths
$BackupDir = Join-Path -Path (Get-Location) -ChildPath "backup_$TS"
$PatchDir  = Join-Path -Path (Get-Location) -ChildPath "patch_$TS"
New-Item -Path $BackupDir -ItemType Directory -Force | Out-Null
New-Item -Path $PatchDir -ItemType Directory -Force | Out-Null
Log "Started. BackupDir=$BackupDir  PatchDir=$PatchDir"
#endregion

#region WinSCP availability check
$winscpDllName = "WinSCP.dll"
$winscpDllPath = Join-Path -Path (Get-Location) -ChildPath $winscpDllName
$hasWinSCP = $false
if (Test-Path $winscpDllPath) {
    try {
        Add-Type -Path $winscpDllPath -ErrorAction Stop
        $hasWinSCP = $true
        Log "WinSCP .NET assembly loaded from $winscpDllPath"
    } catch {
        Log "Found $winscpDllName but failed to load: $_"
    }
} else {
    # Try to detect WinSCP installation
    $possible = @(
        "$env:ProgramFiles\WinSCP\WinSCP.exe",
        "$env:ProgramFiles(x86)\WinSCP\WinSCP.exe"
    ) | Where-Object { Test-Path $_ }
    if ($possible) {
        # try to locate dll alongside exe
        $dllCandidate = Join-Path -Path (Split-Path $possible[0]) -ChildPath "WinSCPnet.dll"
        if (Test-Path $dllCandidate) {
            try { Add-Type -Path $dllCandidate -ErrorAction Stop; $hasWinSCP = $true; Log "WinSCP .NET assembly loaded from $dllCandidate" } catch { Log "Failed loading WinSCPnet.dll: $_" }
        }
    }
}
if (-not $hasWinSCP) {
    Log "WinSCP not available. Script will attempt plain FTP fallback (no TLS) if allowed."
}
#endregion

#region Functions: Generate patch files
function Ensure-Dir([string]$p) { if (-not (Test-Path $p)) { New-Item -Path $p -ItemType Directory -Force | Out-Null } }
function New-File([string]$path, [string]$content) { Ensure-Dir (Split-Path $path); Set-Content -Path $path -Value $content -Encoding UTF8; Log "Wrote $path" }

function Generate-PatchFiles {
    param([string]$base)
    Ensure-Dir $base
    # css
    $cssDir = Join-Path $base "css"; Ensure-Dir $cssDir
    $css = @"
:root{--primary:#0a4d8c;--dark:#0b0b0b;--muted:#666;--accent:#00a86b}
*{box-sizing:border-box}html,body{margin:0;padding:0;font-family:Arial,Helvetica,sans-serif;color:var(--dark)}
.container{max-width:1200px;margin:0 auto;padding:0 16px}header{background:#fff;box-shadow:0 1px 4px rgba(0,0,0,0.06);position:sticky;top:0;z-index:100}
.header-inner{display:flex;align-items:center;justify-content:space-between;padding:12px 0}.logo img{height:56px}
nav ul{list-style:none;margin:0;padding:0;display:flex;gap:18px}nav a{text-decoration:none;color:var(--dark);font-weight:600}
.hero-slider{height:360px;display:flex;align-items:center;justify-content:center;background:#f5f7fb}
.priority-block{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:16px;padding:24px 0}
.card{background:#fff;padding:18px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
footer{background:#0b0b0b;color:#fff;padding:24px 0;margin-top:24px}.footer-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px}
@media(max-width:768px){nav ul{display:none}.logo img{height:44px}}
"@
    New-File (Join-Path $cssDir "style.css") $css

    # robots
    New-File (Join-Path $base "robots.txt") "User-agent: *`nDisallow:`nSitemap: https://dalmiacomputers.in/sitemap.xml"

    # sitemap
    $sitemap = @"
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url><loc>https://dalmiacomputers.in/</loc><changefreq>daily</changefreq></url>
  <url><loc>https://dalmiacomputers.in/pages/products/</loc><changefreq>weekly</changefreq></url>
  <url><loc>https://dalmiacomputers.in/pages/services/</loc><changefreq>weekly</changefreq></url>
  <url><loc>https://dalmiacomputers.in/pages/support/</loc><changefreq>weekly</changefreq></url>
</urlset>
"@
    New-File (Join-Path $base "sitemap.xml") $sitemap

    # header snippet
    $header = @"
<header>
  <div class='container header-inner'>
    <div class='logo'><a href='/'><img src='/assets/dc-logo.svg' alt='Dalmia Computers Logo'></a></div>
    <nav>
      <ul>
        <li><a href='/'>Home</a></li>
        <li><a href='/pages/products/'>Products</a></li>
        <li><a href='/pages/services/'>Services</a></li>
        <li><a href='/pages/support/'>Support</a></li>
      </ul>
    </nav>
  </div>
</header>
"@
    Ensure-Dir (Join-Path $base "snippets")
    New-File (Join-Path $base "snippets\header.html") $header

    # placeholder pages
    $pages = @("products","services","support","tally","careers","lucky-draw")
    foreach ($p in $pages) {
        $pDir = Join-Path $base "pages\$p"; Ensure-Dir $pDir
        $html = @"
<!doctype html>
<html lang='en'>
<head>
  <meta charset='utf-8'>
  <title>$($p.ToUpperInvariant()) - Dalmia Computers</title>
  <meta name='description' content='$p page under construction'>
  <link rel='canonical' href='https://dalmiacomputers.in/pages/$p/'>
  <link rel='stylesheet' href='/css/style.css'>
</head>
<body>
  $header
  <main class='container'>
    <h1>$($p.ToUpperInvariant())</h1>
    <p>This page is under construction. Contact 9734290001 for details.</p>
  </main>
  <footer></footer>
</body>
</html>
"@
        New-File (Join-Path $pDir "index.html") $html
    }

    # assets/logo svg
    $assets = Join-Path $base "assets"; Ensure-Dir $assets
    $svg = @"
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 100'>
  <rect width='100%' height='100%' fill='#0a4d8c'/>
  <text x='50%' y='55%' font-family='Verdana' font-size='20' fill='#fff' text-anchor='middle'>Dalmia Computers</text>
</svg>
"@
    New-File (Join-Path $assets "dc-logo.svg") $svg
    Log "Patch files generated."
}
#endregion

#region Functions: WinSCP operations (if available)
if ($hasWinSCP) {
    function New-WinSCPSession {
        param($host,$user,$password)
        $sessionOptions = New-Object WinSCP.SessionOptions
        # Auto-detect protocol: Sftp if port 22 or use FTPS (explicit) otherwise
        if ($useSecure) {
            # try SFTP first (more common for managed hosts?), fallback to FTP with TLS
            $sessionOptions.Protocol = [WinSCP.Protocol]::Sftp
            $sessionOptions.HostName = $host
            $sessionOptions.UserName = $user
            $sessionOptions.Password = $password
            $sessionOptions.SshHostKeyFingerprint = ""  # empty to allow any; WinSCP may warn
        } else {
            $sessionOptions.Protocol = [WinSCP.Protocol]::Ftp
            $sessionOptions.HostName = $host
            $sessionOptions.UserName = $user
            $sessionOptions.Password = $password
            $sessionOptions.FtpSecure = [WinSCP.FtpSecure]::Explicit
            $sessionOptions.TlsHostCertificateFingerprint = ""
        }
        return $sessionOptions
    }

    function WinSCP-DownloadTree {
        param($sessionOptions, $remotePath, $localPath)
        $session = New-Object WinSCP.Session
        try {
            $session.Open($sessionOptions)
            Log "WinSCP session opened."
            Ensure-Dir $localPath
            $transferOptions = New-Object WinSCP.TransferOptions
            $transferOptions.TransferMode = [WinSCP.TransferMode]::Binary
            $transferResult = $session.GetFiles($remotePath + "/*", $localPath, $False, $transferOptions)
            $transferResult.Check()
            Log "WinSCP download succeeded."
        } catch {
            Log "WinSCP download error: $_"
            throw $_
        } finally {
            $session.Dispose()
        }
    }

    function WinSCP-UploadTree {
        param($sessionOptions, $localDir, $remoteDir)
        $session = New-Object WinSCP.Session
        try {
            $session.Open($sessionOptions)
            Log "WinSCP session opened for upload."
            $transferOptions = New-Object WinSCP.TransferOptions
            $transferOptions.TransferMode = [WinSCP.TransferMode]::Binary
            $transferResult = $session.PutFiles($localDir + "/*", $remoteDir, $False, $transferOptions)
            $transferResult.Check()
            Log "WinSCP upload succeeded: $localDir -> $remoteDir"
        } catch {
            Log "WinSCP upload error: $_"
            throw $_
        } finally {
            $session.Dispose()
        }
    }
}
#endregion

#region Functions: Basic FTP fallback (no TLS)
function Ftp-DownloadRecursive {
    param($host,$user,$pass,$remotePath,$localPath)
    Ensure-Dir $localPath
    Log "Starting plain FTP download from $host:$remotePath (non-TLS)."
    $uriBase = "ftp://$host$remotePath".TrimEnd("/")
    $webclient = New-Object System.Net.WebClient
    $webclient.Credentials = New-Object System.Net.NetworkCredential($user,$pass)
    try {
        # List files via WebRequest to get names (NLST)
        $req = [System.Net.FtpWebRequest]::Create($uriBase)
        $req.Method = [System.Net.WebRequestMethods+Ftp]::ListDirectory
        $req.Credentials = $webclient.Credentials
        $resp = $req.GetResponse()
        $sr = New-Object System.IO.StreamReader($resp.GetResponseStream())
        $entries = @()
        while(-not $sr.EndOfStream) { $entries += $sr.ReadLine() }
        $sr.Close(); $resp.Close()
        foreach ($e in $entries) {
            if ([string]::IsNullOrWhiteSpace($e)) { continue }
            $remoteFile = "$remotePath/$e"
            $localFile = Join-Path $localPath $e
            # Try to download; if directory, this will fail and we skip (naive)
            try {
                $fileUri = "ftp://$host$remoteFile"
                $webclient.DownloadFile($fileUri, $localFile)
                Log "Downloaded $remoteFile"
            } catch {
                # maybe directory -> make dir and recurse
                Ensure-Dir $localFile
                Ftp-DownloadRecursive -host $host -user $user -pass $pass -remotePath $remoteFile -localPath $localFile
            }
        }
    } catch {
        Log "Plain FTP download failed: $_"
        throw $_
    } finally {
        $webclient.Dispose()
    }
}

function Ftp-UploadFile {
    param($host,$user,$pass,$localFile,$remoteFile)
    $uri = "ftp://$host$remoteFile"
    $req = [System.Net.FtpWebRequest]::Create($uri)
    $req.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
    $req.Credentials = New-Object System.Net.NetworkCredential($user,$pass)
    $bytes = [System.IO.File]::ReadAllBytes($localFile)
    $req.ContentLength = $bytes.Length
    $stream = $req.GetRequestStream()
    $stream.Write($bytes,0,$bytes.Length)
    $stream.Close()
    $resp = $req.GetResponse()
    $resp.Close()
    Log "Uploaded $localFile -> $remoteFile"
}
#endregion

#region Main flow
try {
    # Step 1: Download backup (WinSCP preferred)
    if ($hasWinSCP -and $useSecure) {
        Log "Using WinSCP (secure) for backup."
        $so = New-WinSCPSession -host $ftpHost -user $ftpUser -password $ftpPass
        $localBackupTarget = Join-Path $BackupDir "*"
        # WinSCP GetFiles with wildcard will get files in remoteRoot; better to download remote folder recursively:
        $session = New-Object WinSCP.Session
        try {
            $session.Open($so)
            Log "WinSCP session opened for backup."
            Ensure-Dir $BackupDir
            $transferOptions = New-Object WinSCP.TransferOptions
            $transferOptions.TransferMode = [WinSCP.TransferMode]::Binary
            $session.GetFiles($remoteRoot + "/*", $BackupDir, $True, $transferOptions).Check()
            Log "Backup downloaded to $BackupDir"
        } catch {
            Log "WinSCP backup error: $_"
            throw $_
        } finally {
            $session.Dispose()
        }
    } elseif ($hasWinSCP -and -not $useSecure) {
        Log "Using WinSCP (FTP explicit) for backup."
        $so = New-WinSCPSession -host $ftpHost -user $ftpUser -password $ftpPass
        $session = New-Object WinSCP.Session
        try {
            $session.Open($so)
            Ensure-Dir $BackupDir
            $session.GetFiles($remoteRoot + "/*", $BackupDir, $True).Check()
            Log "Backup downloaded to $BackupDir"
        } catch {
            Log "WinSCP backup error: $_"
            throw $_
        } finally {
            $session.Dispose()
        }
    } else {
        Log "WinSCP not present or disabled. Falling back to plain FTP (may fail if FTPS required)."
        try {
            Ftp-DownloadRecursive -host $ftpHost -user $ftpUser -pass $ftpPass -remotePath $remoteRoot -localPath $BackupDir
            Log "FTP backup downloaded to $BackupDir"
        } catch {
            Log "FTP backup failed: $_"
            throw $_
        }
    }

    # Zip backup for quick restore
    $zipPath = "$BackupDir.zip"
    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    [System.IO.Compression.ZipFile]::CreateFromDirectory($BackupDir, $zipPath)
    Log "Backup zipped to $zipPath"

    # Step 2: Generate patch files
    Generate-PatchFiles -base $PatchDir

    # Step 3: Upload patch files (css, assets, pages, robots, sitemap)
    if ($hasWinSCP -and $useSecure) {
        Log "Uploading patch using WinSCP (secure)."
        $so = New-WinSCPSession -host $ftpHost -user $ftpUser -password $ftpPass
        $session = New-Object WinSCP.Session
        try {
            $session.Open($so)
            $session.PutFiles((Join-Path $PatchDir "css\*"), (Join-Path $remoteRoot "css")).Check()
            $session.PutFiles((Join-Path $PatchDir "assets\*"), (Join-Path $remoteRoot "assets")).Check()
            $session.PutFiles((Join-Path $PatchDir "pages\*"), (Join-Path $remoteRoot "pages")).Check()
            # top-level files
            foreach ($file in @("robots.txt","sitemap.xml")) {
                $local = Join-Path $PatchDir $file
                if (Test-Path $local) {
                    $session.PutFiles($local, (Join-Path $remoteRoot $file)).Check()
                    Log "Uploaded $file to $remoteRoot/$file"
                }
            }
            Log "Patch upload complete via WinSCP."
        } catch {
            Log "WinSCP upload error: $_"
            throw $_
        } finally {
            $session.Dispose()
        }
    } else {
        Log "Uploading patch using plain FTP (non-TLS)."
        # We'll upload files individually. Create remote directories via WebRequest not trivial; we'll attempt upload and create dirs by uploading to paths.
        $itemsToUpload = @(
            @{ Local = Join-Path $PatchDir "robots.txt"; Remote = "$remoteRoot/robots.txt" },
            @{ Local = Join-Path $PatchDir "sitemap.xml"; Remote = "$remoteRoot/sitemap.xml" }
        )
        # upload css
        Get-ChildItem -Path (Join-Path $PatchDir "css") -File -Recurse | ForEach-Object {
            $rel = $_.FullName.Substring((Join-Path $PatchDir "css").Length).TrimStart('\','/')
            $remote = "$remoteRoot/css/$rel" -replace '\\','/'
            $itemsToUpload += @{ Local = $_.FullName; Remote = $remote }
        }
        # upload assets
        Get-ChildItem -Path (Join-Path $PatchDir "assets") -File -Recurse | ForEach-Object {
            $rel = $_.FullName.Substring((Join-Path $PatchDir "assets").Length).TrimStart('\','/')
            $remote = "$remoteRoot/assets/$rel" -replace '\\','/'
            $itemsToUpload += @{ Local = $_.FullName; Remote = $remote }
        }
        # upload pages
        Get-ChildItem -Path (Join-Path $PatchDir "pages") -File -Recurse | ForEach-Object {
            $rel = $_.FullName.Substring((Join-Path $PatchDir "pages").Length).TrimStart('\','/')
            $remote = "$remoteRoot/pages/$rel" -replace '\\','/'
            $itemsToUpload += @{ Local = $_.FullName; Remote = $remote }
        }
        foreach ($it in $itemsToUpload) {
            try {
                Ftp-UploadFile -host $ftpHost -user $ftpUser -pass $ftpPass -localFile $it.Local -remoteFile $it.Remote
            } catch {
                Log "FTP upload failed for $($it.Local): $_"
            }
        }
        Log "Plain FTP upload attempts finished."
    }

    # Step 4: Verify HTTP
    try {
        Log "Verifying site https://$domain ..."
        $resp = Invoke-WebRequest -Uri "https://$domain" -UseBasicParsing -TimeoutSec 15 -ErrorAction Stop
        Log "HTTP(S) status: $($resp.StatusCode)  Size: $($resp.RawContentLength)"
    } catch {
        Log "HTTPS verification failed: $_. Trying HTTP..."
        try {
            $resp2 = Invoke-WebRequest -Uri "http://$domain" -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
            Log "HTTP status: $($resp2.StatusCode)  Size: $($resp2.RawContentLength)"
        } catch {
            Log "HTTP verification failed: $_"
        }
    }

    Log "One-click patch finished successfully. Check $LogFile and backup zip at $zipPath"
} catch {
    Log "ERROR in main flow: $_"
    throw
}
#endregion

# EOF
